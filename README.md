# Приложение управления аккаунтами &mdash; Тестовое задание

## Техническое задание
Разработать REST  WebAPI сервис для работы с учетными записями. Методы сервиса должны выполнять следующий функционал:
1. Создание пользователя
2. Получение существующего пользователя по ID
3. Поиск пользователя по нескольким полям

## Требования к заданию
1. При создании пользователя поля должны пройти валидацию:
	- Номер паспорта должен иметь формат **XXXX**  **XXXXXX**
	- Телефон должен иметь формат **7ХХХХХХХХХХ**
	- Электронная почта должна иметь правильный формат
2. Пользователь может быть создан из разных приложений. Тип приложения определяется по обязательному HTTP-заголовку X-Device. В зависимости от переданного заголовка меняется набор обязательных полей для создания пользователя:
	- **mail** – обязательны только имя и электронная почта
	- **mobile** – обязательный только номер телефона
	- **web** – ввести поля обязательны, кроме электронной почты и адреса
3. Электронная почта и телефон должны быть уникальными, создание пользователя с повторениями должно возвращать ошибку
4. Поля, по которым можно искать пользователя: **фамилия, имя, отчество, телефон, электронная почта**. Должен быть функционал поиска по одному, либо по нескольким полям из этого списка

## Дополнительные требования
1. Основной стек для реализации: **.NET 8**, **ASP.NET Core**, **EF Core**, **SQL Server**
2. Логика приложения должна быть покрыта Unit или интеграционными тестами. Использовать **NUnit** или **XUnit**
3. Должны присутствовать миграции БД, а также первоначальные данные для проверки работоспособности проекта
4. Проект должен запускаться сразу, без внесения каких-либо изменений в проект
5. Dockerfile проекта для создания образа и docker-compose для подготовки окружения вместе с контейнером БД. Проверка healthcheck сервиса MSSQL
6. Структура проекта по дизайну DDD
7. Для тестирования использовать подменный провайдер БД (InMemory, SQLite)

## Модели и DTO
### User
- ID
- Имя (FirstName)
- Фамилия (LastName)
- Отчество (MiddleName)
- Дата рождения (Birthday)
- Номер паспорта (PassportNumber)
- Телефон (PhoneNumber)
- Электронная почта (Email)
- Адрес (Address)

### UserCreateDto | MailUserCreateDto | MobileUserCreateDto | WebUserCreateDto
- Имя
- Фамилия
- Отчество
- Дата рождения
- Номер паспорта
- Телефон
- Электронная почта
- Адрес

*Модели отличаются только атрибутами для проверки данных*

### FindUserDto
- Имя
- Фамилия
- Отчество
- Дата рождения
- Электронная почта

## Методы
### API
#### `GET /api/users/{id}`
**Описание**:
Возвращает информацию о пользователе по его идентификатору.

**Параметры**: 
- `id (int, обязательный)` &mdash; уникальный идентификатор пользователя.

**Возвращает**:
- `200 OK`: Возвращает информацию о пользователе в формате JSON.
- `404 Not Found`: Если пользователь с указанным идентификатором не найден.

#### `POST /api/users`
**Описание**:
Добавляет пользователя в базу данных.

**Параметры**: 
- `Тело запроса (UserCreateDto, обязательный)` &mdash; данные для создания пользователя в формате json.

**Заголовки**:
- `X-Device (string, обязательный)` &mdash; идентификатор устройства для проверки.

**Возвращает**:
- `200 OK`: Пользователь создан успешно.
	- `The user was created successfully`
- `400 Bad Request`: Произошла ошибка валидации. Возвращает ModelState с ошибками.

**Пример корректного запроса**:

    POST /api/users
    X-Device: mail
    Content-Type: application/json
    {
	    "FirstName": "John",
	    "LastName": "Doe",
	    "Email": "john.doe@example.com"
	}

**Пример некорректного запроса**:

    POST /api/users
    X-Device: web
    Content-Type: application/json
    {
	    "FirstName": "Alice",
	    "LastName": "Smith",
	    "Email": "alice.smith@example.com",
	    "Birthday": "1985-04-12"
	}

**Пример успешного ответа**:

    HTTP/1.1 200 OK
    The user was created successfully
    
**Пример ответа с ошибкой**:

    HTTP/1.1 400 Bad Request

#### `POST /api/users/find`
**Описание**:
Выполняет поиск пользователя на основе переданных данных.

**Параметры**: 
- `Тело запроса (FindUserDto, обязательный)` &mdash; данные для поиска пользователя в формате json.

**Возвращает**:
- `200 OK`: Пользователь найден. Возвращает данные пользователя в формате JSON.
- `404 Not Found`: Пользователь с указанными данными не найден.

**Пример запроса**:

    POST /api/users/find
    Content-Type: application/json
    {
	    "firstName": "John",
	    "lastName": "Doe",
	    "email": "john.doe@example.com"
	}

**Пример успешного ответа**:

    HTTP/1.1 200 OK
    {
	    "id": 1, "firstName": "John",
	    "lastName": "Doe",
	    "email": "john.doe@example.com",
	    "phoneNumber": "71234567890",
	    "birthday": "1990-01-01"
    }
**Пример ответа с ошибкой**:

    HTTP/1.1 404 Not Found

### API X-Device фильтр
#### `OnActionExecuting(ActionExecutingContext context)`
**Описание**:
Фильтр для методов контроллеров, проверяющий наличие заголовка X-Device в запросе. Если заголовок отсутствует или содержит недопустимое значение, запрос отклоняется.

**Возвращает**:
- `400 Bad Request`:
	- Если заголовок отсутствует: `Missing required header: X-Device` 
	- Если заголовок содержит недопустимое значение:
	`Wrong required header: X-Device`
- Если заголовок валиден, выполнение запроса продолжается.

**Примечания**:
- Допустимые значения: `"mail"`, `"mobile"`, `"web"`.

### UserService
#### `GetUserByIdAsync(int id)`
**Описание**:
Возвращает информацию о пользователе по его идентификатору.

**Параметры**: 
- `id (int, обязательный)` &mdash; уникальный идентификатор пользователя.

**Возвращает**:
- `User?`: Объект пользователя, если он найден в базе данных, либо `null`, если пользователь отсутствует.

#### `FindUserAsync(FindUserDto userData)`
**Описание**:
Выполняет поиск пользователя на основе переданных данных.

**Параметры**: 
- `FindUserDto, обязательный` &mdash; данные для поиска пользователя.

**Возвращает**:
- `User?`: Объект пользователя, если он найден в базе данных, либо `null`, если пользователь отсутствует.

#### `ValidateAndCreateUserAsync(string xDevice, UserCreateDto user)`
**Описание**:
Асинхронно выполняет валидацию данных на основе заголовка `X-Device` и создает пользователя в случае успеха.

**Параметры**: 
- `xDevice (string, обязательный)`
- `user (UserCreateDto, обязательный)` &mdash; данные для создания пользователя.

**Возвращает**:
- `(bool isValid, List<ValidationResult> errors)`:
	- `isValid`: Флаг валидности данных.
	- `errors`: Список ошибок валидации, если они есть.

**Алгоритм работы**:
1. В зависимости от `xDevice`, выполняется преобразование данных пользователя в DTO (`MailUserCreateDto`, `MobileUserCreateDto`, `WebUserCreateDto`).
2. Если значение `xDevice` не является допустимым, возвращается ошибка валидации.
3. Проверяется наличие пользователя с таким же email или номером телефона в БД:
	- Если пользователь существует, добавляется ошибка валидации на каждое из повторяющихся полей.
5. Выполняется валидация преобразованного DTO с помощью атрибутов.
6. Если валидация не пройдена, возвращается список ошибок.
7. Если валидация успешна, то `UserCreateDto` преобразуются в `User` и сохраняется в базе данных.
8. Возвращается флаг успешной валидации и пустой список ошибок.

### UserRepository
#### `CreateUserAsync(User user)`
**Описание**:
Добавляет пользователя в базу данных.

**Параметры**: 
- `User, обязательный` &mdash; данные пользователя.

#### `GetUserByIdAsync(int id)`
**Описание**:
Ищет в базе данных пользователя с указанным id.

**Параметры**: 
- `id (int, обязательный)` &mdash; id пользователя.

**Возвращает**:
- `User?`: Объект пользователя, если он найден в базе данных, либо `null`, если пользователь отсутствует.

#### `FindUserAsync(string? firstName = null, string? lastName = null, string? middleName = null, string? phoneNumber = null, string? email = null)`
**Описание**:
Выполняет поиск пользователя на основе переданных данных.

**Параметры**: 
- `firstName (string?)` 
- `lastName (string?)`
- `middleName (string?)`
- `phoneNumber (string?)`
- `email (string?)`

**Возвращает**:
- `User?`: Объект пользователя, если он найден в базе данных, либо `null`, если пользователь отсутствует или ничего из введенных данных не заполнено.
